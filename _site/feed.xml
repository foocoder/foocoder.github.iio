<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
	<channel>
		<title>Meta Coder</title>
		<description>{&quot;meta&quot;=&gt;&quot;Reading, Thinking, Coding&quot;, &quot;subtitle&quot;=&gt;&quot;Hi, I&#39;m Meta Coder!&lt;br/&gt;Reading, Thinking and Coding is My Life.&quot;}</description>
		<link>http://foocoder.github.io</link>
		<atom:link href="http://foocoder.github.io/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>由一道题引起的对内存泄露的思考</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;最近遇到了这么一道题：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;使用 char &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; p &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; new char[100] 申请一段内存， 然后使用delete p 释放， 有什么问题？

A. 会有内存泄露
B. 不会有内存泄露，但不建议使用
C. 编译就会报错，必须使用delete &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; p
D. 编译没问题，运行会直接崩溃&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;看了这题目，首先第一感觉不由自主的就选了A。我们通常知道&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt; 与&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete[]&lt;/code&gt;当然需要配对使用，
否则的就会导致内存泄露。这是直观的感觉。&lt;/p&gt;

&lt;p&gt;然而第一感觉却往往是不正确的。正确答案是B。瞬间模糊了自己对&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;的概念。虽说最近也在断断续续地看着
《深度探索C++对象模型》以及《Effective C++》，对&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;多少也有些了解。但这道题却让我对&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;的认知
一夜回到了解放前。于是决定透彻的了解下&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;的细节。&lt;/p&gt;

&lt;p&gt;首先需要明确的概念是内存泄露(Memory Leak)的概念。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以这么说，假设我申请了一块1MB大小的地址，用一个ptr来指向该内存的首地址，但是在程序运行的时候不小心把ptr的值给覆盖掉了，所以现在这块内存的地址我无法获取，所以这块内存就相当于消失了。因为对于OS
的内存管理程序来讲，这块内存是有用的，但是对于程序而言，却缺乏该内存的首地址导致无法使用。&lt;/p&gt;

&lt;p&gt;这么看来，我之前理解的&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]&lt;/code&gt;来分配n块地址然后由&lt;code class=&quot;highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;来回收n块地址，而&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;只能回收一块地址，所以导致内存泄露是完全不对的了。
内存泄露是指没有回收但指针却没了。如果&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;只是回收了第一块地址的话那么后续的地址没被回收，而且指针&lt;code class=&quot;highlighter-rouge&quot;&gt;p[1],p[2]&lt;/code&gt;仍然存在，这样的话也算不上是内存泄露啊。&lt;/p&gt;

&lt;p&gt;那这样的话，为什么很多书上会讲&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete[]&lt;/code&gt;不匹配使用的话会导致内存泄露呢？
如果真的导致了内存泄露，那究竟是什么时候会泄露，什么时候不会泄露呢？&lt;/p&gt;

&lt;p&gt;看来如果真想了解本质，必须知道&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;究竟干了什么事。&lt;/p&gt;

&lt;p&gt;参考来自&lt;a href=&quot;http://kelvinh.github.io/blog/2014/04/19/research-on-operator-new-and-delete/&quot;&gt;@Kelvin&lt;/a&gt;
大神的博文，我们来看看C++标准库的实现之一Clang的libcxx如何实现&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new/delete&lt;/code&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bad_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_handler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_new_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bad_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;由此看来，&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;不过是调用c函数库中系统函数&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc/free&lt;/code&gt;而已。而对于&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete[]&lt;/code&gt;也类似&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bad_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;因此，&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete[]&lt;/code&gt;只不过是对&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;的一个调用而已。(Ps: 还是有区别的，其中编译器做了一些工作，下文会详细介绍)。&lt;/p&gt;

&lt;p&gt;现在我们再看 char * p = new char[100]; delete p; 整个过程。
其本质是类似这样一种形式。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//new
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//delete
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这样将的话也不会出现内存泄露的问题，那究竟什么时候能出现内存泄露呢？&lt;/p&gt;

&lt;p&gt;另一个对&lt;code class=&quot;highlighter-rouge&quot;&gt;new/delete&lt;/code&gt;的class认知：
对于用户定义class类型，我们对&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;的认知是分三步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过malloc来申请一块内存;&lt;/li&gt;
  &lt;li&gt;在内存上调用构造函数;&lt;/li&gt;
  &lt;li&gt;返回该class类型的指针。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;相对的&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;是两部：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用对应的析构函数;&lt;/li&gt;
  &lt;li&gt;将内存free掉。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那我们提出这样的假设，是不是用户定义的class类型的与内置基本类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete[]&lt;/code&gt;不一致？
既然有疑问，就需要实验来验证下结果。
我们三组不同类型进行&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete[]&lt;/code&gt;来查看其内存模型。
这三组类型按照一下标准分类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;内置类型数组(int);&lt;/li&gt;
  &lt;li&gt;POD类型数组;&lt;/li&gt;
  &lt;li&gt;成员函数包含指向堆的指针class数组,带有构造函数以及析构函数,我们称之为用户定义类型;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;malloc.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;complexStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;complexStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_ptr_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xCDCDCDCD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;complexStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ptr_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ptr_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//内置类型数组
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;BEFORE NEW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptrInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// malloc 最小内存块32bytes, 每次增加16bytes。需要8bytes的额外空间。
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ptrInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xCDCDCDCD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;AFTER NEW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptrInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//No Memory Leak
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;AFTER DELETE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//POD类型数组
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;BEFORE NEW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;arrPOD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptrArrPOD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrPOD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;AFTER NEW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptrArrPOD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//No Memory Leak
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;AFTER DELETE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrPOD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//用户定义类型数组
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;BEFORE NEW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;complexStruct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptrComplexStruct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;complexStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;AFTER NEW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptrComplexStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Memory Leak; 运行到这里会出现segment fault
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;AFTER DELETE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;malloc_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;complexStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;说明一下，malloc_stats()函数用来查看内存中malloc()申请的内存状况。
另外，程序运行到 delete complexStruct 的时候会segment fault。
我们主要是用gdb来跟踪，然后来查看内存中这些数组的数据。
编译的时候使用&lt;code class=&quot;highlighter-rouge&quot;&gt;gdb -O0&lt;/code&gt;来关闭优化，防止编译器将一些信息优化掉。
Ps. 每次运行时会将其余部分注释掉，只测试本部分的数据内存模型。&lt;/p&gt;

&lt;p&gt;首先对于内置类型(int * ptrInt = new int [10])，在&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]&lt;/code&gt;之后ptrInt的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602010&lt;/code&gt;,为了更方便的查看数据，我们将
里边的值都赋为&lt;code class=&quot;highlighter-rouge&quot;&gt;0xcdcdcdcd&lt;/code&gt;，同过&lt;code class=&quot;highlighter-rouge&quot;&gt;x/8xg 0x602000&lt;/code&gt;来显示从&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602000&lt;/code&gt;开始的64bytes的内存如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;mh&quot;&gt;0x602000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000031&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602010&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602020&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602030&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000020fd1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中有个问题是ptrInt的开始地址是&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602010&lt;/code&gt;，但我们为什么要从&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602000&lt;/code&gt;开始呢？
实际上，&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc/free&lt;/code&gt;调用的时候每次传过来的指针有个头部信息，该信息一般用来存放32bit
的内存块信息，包括该块的大小以及是否空闲。我们这里的是&lt;code class=&quot;highlighter-rouge&quot;&gt;0x00000031&lt;/code&gt;，最后一位为1表明
该块被使用，剩下的&lt;code class=&quot;highlighter-rouge&quot;&gt;0x00000030&lt;/code&gt;表示该块大小为48个bytes。所以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;返回的指针实际上
不是你使用的内存的首地址，而是越过了8个字节的头部信息的位置，而&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;的时候自动会将
指针回退8个字节来提取出该内存块的信息。一旦&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;的时候找不到内存块信息则会出现segment fault的错误。(Ps. 最后一句话纯属个人理解)&lt;/p&gt;

&lt;p&gt;下面看下POD类型数组的结构发现与内置类型的结果一模一样。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;mh&quot;&gt;0x602000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000031&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602010&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602020&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602030&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0xcdcdcdcdcdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000020fd1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所以POD的&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete&lt;/code&gt;也不会导致内存泄露的问题。&lt;/p&gt;

&lt;p&gt;接下来看一下用户定义的class数组。这一次&lt;code class=&quot;highlighter-rouge&quot;&gt;p ptrComplexStruct&lt;/code&gt;的时候发现地址不再是&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602010&lt;/code&gt;,而成了&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602018&lt;/code&gt;。
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;x/32xg 0x602000&lt;/code&gt;来查看从&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602000&lt;/code&gt;开始的256个bytes内存如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;mh&quot;&gt;0x602000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000061&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602010&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x000000000000000a&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000602070&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602020&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000602090&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x00000000006020b0&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602030&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x00000000006020d0&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x00000000006020f0&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602040&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000602110&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000602130&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602050&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000602150&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000602170&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602060&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000602190&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000021&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602070&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x00000000cdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602080&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000021&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x602090&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x00000000cdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x6020a0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000021&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x6020b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x00000000cdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x6020c0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000021&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x6020d0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x00000000cdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x6020e0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000021&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x6020f0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;mh&quot;&gt;0x00000000cdcdcdcd&lt;/span&gt;      &lt;span class=&quot;mh&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;0x00000061&lt;/code&gt;跟之前的&lt;code class=&quot;highlighter-rouge&quot;&gt;0x00000031&lt;/code&gt;一样是malloc出的内存块的头部，如果按照前种情况来看，说明对于&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;来讲首地址应该是
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602010&lt;/code&gt;，而我们发现通过malloc出的内存块在头部之后又添加了一个8 字节的&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;的头部，存放的内容是&lt;code class=&quot;highlighter-rouge&quot;&gt;0xa&lt;/code&gt;，也就是10，即该
数组的大小。之后从&lt;code class=&quot;highlighter-rouge&quot;&gt;0x602018&lt;/code&gt;开始才是真正的数据。这样的话也不難理解了。因为我们的class里边含有析构函数，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;的
时候需要将数组中的每个object进行析构，而数组的个数就被存储在整个数组的开头部分，占8个bytes。&lt;/p&gt;

&lt;p&gt;那class数组的结构有时包含数组长度，有时不包含数组长度，是通过什么判断的呢？
根据上边我们了解的&lt;code class=&quot;highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;的过程中可以得知数组长度主要用途是为了&lt;code class=&quot;highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;时进行析构的，所以我们假设结构的不同跟class是否
含有析构函数有关。&lt;/p&gt;

&lt;p&gt;最终得证。如果把用户定义类型class的析构函数注释掉，则其内存模型中数组长度就不存在了。
而如果给POD类型添加一个析构函数，其内存模型也会添加一个数组长度。&lt;/p&gt;

&lt;p&gt;好了，现在真相大白。总结一下， 普通的malloc申请的内存会包含一个头部信息存储块的大小以及使用信息，free通过读取这些信息来
进行回收，否则会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;segment fault&lt;/code&gt;错误(个人理解)， 而对于包含析构函数的的class，&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]&lt;/code&gt;会对申请的块继续包裹一个头部信息
来存储数组的大小，&lt;code class=&quot;highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;根据这个大小来一一进行析构。&lt;/p&gt;

&lt;p&gt;而对于内存泄露，如果普通的内置类型以及class不包含动态分配的指针的情况下，利用&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete&lt;/code&gt;组合不会导致内存泄露，因为这本质
跟&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc/free&lt;/code&gt;是一样的。而如果class中有&lt;code class=&quot;highlighter-rouge&quot;&gt;new/malloc&lt;/code&gt;动态分配的内存，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]/delete&lt;/code&gt;的话就会导致内存泄露。这是因为class内部的
内存本身应该由object的析构函数来回收内存，而由于&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;只会析构一个object，所以其他的objects成员的内存并没有得到回收，但
这些存放指针的内存却被回收了，从而导致了内存泄露。&lt;/p&gt;

&lt;p&gt;另外，这个程序为什么会&lt;code class=&quot;highlighter-rouge&quot;&gt;segment fault&lt;/code&gt;呢？
这是由于对于g++来讲，&lt;code class=&quot;highlighter-rouge&quot;&gt;new[]&lt;/code&gt;出的内存第一个位置放的是数组长度，而只有&lt;code class=&quot;highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;才能读懂这种模型，&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;的话会直接将第一个
位置当作object的起始位置来处理，这样的话导致的模型不匹配处理出问题。&lt;/p&gt;
</description>
				
				<pubDate>Thu, 26 May 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/c/c++/2016/05/26/Look-Inside-Memory-Leak/</link>
				<guid isPermaLink="true">http://foocoder.github.io/c/c++/2016/05/26/Look-Inside-Memory-Leak/</guid>
			</item>
		
			<item>
				<title>C++异常机制的实现方式和开销分析</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;Ps: 文章系转自&lt;a href=&quot;http://baiy.cn&quot;&gt; @白杨 &lt;/a&gt;先生的&lt;a href=&quot;http://baiy.cn//doc/cpp/index.htm&quot;&gt; C++编码规范与指导 &lt;/a&gt;中一文，&lt;a href=&quot;http://baiy.cn/doc/cpp/inside_exception.htm&quot;&gt;原文链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在我几年前开始写《C++编码规范与指导》一文时，就已经规划着要加入这样一篇讨论 C++ 异常机制的文章了。没想到时隔几年以后才有机会把这个尾巴补完 :-)。&lt;/p&gt;

&lt;p&gt;还是那句开场白：“在恰当的场合使用恰当的特性” 对每个称职的 C++ 程序员来说都是一个基本标准。想要做到这点，就必须要了解语言中每个特性的实现方式及其时空开销。异常处理由于涉及大量底层内容，向来是 C++ 各种高级机制中较难理解和透彻掌握的部分。本文将在尽量少引入底层细节的前提下，讨论 C++ 中这一崭新特性，并分析其实现开销：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;关于线程&lt;/li&gt;
  &lt;li&gt;函数的调用和返回&lt;/li&gt;
  &lt;li&gt;C++ 函数的调用和返回&lt;/li&gt;
  &lt;li&gt;栈回退（Stack Unwind）机制&lt;/li&gt;
  &lt;li&gt;异常捕获机制&lt;/li&gt;
  &lt;li&gt;异常的抛出&lt;/li&gt;
  &lt;li&gt;Windows 中的结构化异常处理&lt;/li&gt;
  &lt;li&gt;异常处理机制的开销分析&lt;/li&gt;
  &lt;li&gt;小节&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;关于线程&lt;/h1&gt;

&lt;p&gt;进程和线程的概念相信各位看官早已耳熟能详。在这里，我只想带大家回忆几点重要概念：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个进程中可以同时包含多个线程。
　&lt;/li&gt;
  &lt;li&gt;我们通常认为线程是操作系统可识别的最小并发执行和调度单位（不要跟俺说还有 Green Thread 或者 Fiber，OS Kernel 不认识也不参与这些物件的调度）。
　&lt;/li&gt;
  &lt;li&gt;同一进程中的多个线程共享代码段（代码和常量）、数据段（静态和全局变量）和扩展段（堆存储），但是每个线程有自己的栈段。栈段又叫运行时栈，用来存放所有局部变量和临时变量（参数、返回值、临时构造的变量等）。这一条对下文中的某些概念来说是非常重要的 。但是请注意，这里提到的各个“段”都是逻辑上的说法，在物理上某些硬件架构或者操作系统可能不使用段式存储。不过没关系，编译器会保证这些逻辑概念和假设的前提条件对每个 C/C++ 程序员来说始终是成立的。
　&lt;/li&gt;
  &lt;li&gt;由于共享了除栈以外的所有内存地址段，线程不可以有自己的“静态”或“全局”变量，为了弥补这一缺憾，操作系统通常会提供一种称为 TLS（Thread Local Storage，即：“线程本地存储”）的机制。通过该机制可以实现类似的功能。TLS 通常是线程控制块（TCB）中的某个指针所指向的一个指针数组，数组中的每个元素称为一个槽（Slot），每个槽中的指针由使用者定义，可以指向任意位置（但通常是指向堆存储中的某个偏移）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;section-1&quot;&gt;函数的调用和返回&lt;/h1&gt;

&lt;p&gt;接着我们来回顾下一个预备知识：编译器如何实现函数的调用和返回。一般来说，编译器会为当前调用栈里的每个函数建立一个栈框架（Stack Frame）。“栈框架”担负着以下重要任务：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;传递参数：通常，函数的调用参数总是在这个函数栈框架的最顶端。&lt;/li&gt;
  &lt;li&gt;传递返回地址：告诉被调用者的 return 语句应该 return 到哪里去，通常指向该函数调用的下一条语句（代码段中的偏移）。&lt;/li&gt;
  &lt;li&gt;存放调用者的当前栈指针：便于清理被调用者的所有局部变量、并恢复调用者的现场。&lt;/li&gt;
  &lt;li&gt;存放当前函数内的所有局部变量：记得吗？刚才说过所有局部和临时变量都是存储在栈上的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后再复习一点：栈是一种“后进先出”（LIFO）的数据结构，不过实际上大部分栈的实现都支持随机访问。&lt;/p&gt;

&lt;p&gt;下面我们来看个具体例子：&lt;/p&gt;

&lt;p&gt;假设有 FuncA、FuncB 和 FuncC 三个函数，每个函数均接收两个整形值作为其参数。在某线程上的某一时间段内，FuncA 调用了 FuncB，而 FuncB 又调用了 FuncC。则，它们的栈框架看起来应该像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/inside_exception_stackframe1.png&quot; alt=&quot;图1函数调用栈框架示例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正如上图所示的那样，随着函数被逐级调用，编译器会为每一个函数建立自己的栈框架，栈空间逐渐消耗。随着函数的逐级返回，该函数的栈框架也将被逐级销毁，栈空间得以逐步释放。顺便说一句，递归函数的嵌套调用深度通常也是取决于运行时栈空间的剩余尺寸。&lt;/p&gt;

&lt;p&gt;这里顺便解释另一个术语：调用约定（calling convention）。调用约定通常指：调用者将参数压入栈中（或放入寄存器中）的顺序，以及返回时由谁（调用者还是被调用者）来清理这些参数等细节规程方面的约定。&lt;/p&gt;

&lt;p&gt;最后再说一句，这里所展示的函数调用乃是最“经典”的方式。实际情况是：在开启了优化选项后，编译器可能不会为一个内联甚至非内联的函数生成栈框架，编译器可能使用很多优化技术消除这个构造。不过对于一个 C/C++ 程序员来说，达到这样的理解程度通常就足够了。&lt;/p&gt;

&lt;h1 id=&quot;c-&quot;&gt;C++ 函数的调用和返回&lt;/h1&gt;

&lt;p&gt;首先澄清一点，这里说的 “C++ 函数”是指：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;该函数可能会直接或间接地抛出一个异常：即该函数的定义存放在一个 C++ 编译（而不是传统 C）单元内，并且该函数没有使用“throw()”异常过滤器。&lt;/li&gt;
  &lt;li&gt;或者该函数的定义内使用了 try 块。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上两者满足其一即可。为了能够成功地捕获异常和正确地完成栈回退（stack unwind），编译器必须要引入一些额外的数据结构和相应的处理机制。我们首先来看看引入了异常处理机制的栈框架大概是什么样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/inside_exception_stackframe2.png&quot; alt=&quot;图2C++函数调用栈框架示例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由图2可见，在每个 C++ 函数的栈框架中都多了一些东西。仔细观察的话，你会发现，多出来的东西正好是一个 EXP 类型的结构体。进一步分析就会发现，这是一个典型的单向链表式结构：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;piPrev 成员指向链表的上一个节点，它主要用于在函数调用栈中逐级向上寻找匹配的 catch 块，并完成栈回退工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;piHandler 成员指向完成异常捕获和栈回退所必须的数据结构（主要是两张记载着关键数据的表：“try”块表：&lt;strong&gt;tblTryBlocks&lt;/strong&gt; 及“栈回退表”：&lt;strong&gt;tblUnwind&lt;/strong&gt;）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nStep 成员用来定位 try 块，以及在栈回退表中寻找正确的入口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要说明的是：&lt;strong&gt;编译器会为每一个“C++ 函数”定义一个 EHDL 结构，不过只会为包含了“try”块的函数定义 tblTryBlocks 成员&lt;/strong&gt;。此外，异常处理器还会为每个线程维护一个指向当前异常处理框架的指针。该指针指向异常处理器链表的链尾，通常存放在某个 TLS 槽或能起到类似作用的地方。&lt;/p&gt;

&lt;p&gt;最后，请再看一遍图2，并至少对其中的数据结构留下一个大体印象。我们会在后面多个小节中详细讨论它们。&lt;/p&gt;

&lt;p&gt;注意：为了简化起见，本文中描述的数据结构内，大多省略了一些与话题无关的成员。&lt;/p&gt;

&lt;h1 id=&quot;stack-unwind&quot;&gt;栈回退（Stack Unwind）机制&lt;/h1&gt;

&lt;p&gt;“栈回退”是伴随异常处理机制引入 C++ 中的一个新概念，主要用来确保在异常被抛出、捕获并处理后，所有生命期已结束的对象都会被正确地析构，它们所占用的空间会被正确地回收。&lt;/p&gt;

&lt;p&gt;受益于栈回退机制的引入，以及 C++ 类所支持的“资源申请即初始化”语意，使得我们终于能够彻底告别既不优雅也不安全的 setjmp/longjmp 调用，简便又安全地实现远程跳转了。我想这也是 C++ 异常处理机制在错误处理以外唯一一种合理的应用方式了。&lt;/p&gt;

&lt;p&gt;下面我们就来具体看看编译器是如何实现栈回退机制的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/inside_exception_stackunwind.png&quot; alt=&quot;图3C++栈回退机制&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图3中的“FuncUnWind”函数内，所有真实代码均以黑色和蓝色字体标示，编译器生成的代码则由灰色和橙色字体标明。此时，在图2里给出的 nStep 变量和 tblUnwind 成员作用就十分明显了。&lt;/p&gt;

&lt;p&gt;nStep 变量用于跟踪函数内局部对象的构造、析构阶段。再配合编译器为每个函数生成的 tblUnwind 表，就可以完成退栈机制。表中的 pfnDestroyer 字段记录了对应阶段应当执行的析构操作（析构函数指针）；pObj 字段则记录了与之相对应的对象 this 指针偏移。将 pObj 所指的偏移值加上当前栈框架基址（EBP），就是要代入 pfnDestroyer 所指析构函数的 this 指针，这样即可完成对该对象的析构工作。而 nNextIdx 字段则指向下一个需要析构对象所在的行（下标）。&lt;/p&gt;

&lt;p&gt;在发生异常时，异常处理器首先检查当前函数栈框架内的 nStep 值，并通过 piHandler 取得 tblUnwind[] 表。然后将 nStep 作为下标带入表中，执行该行定义的析构操作，然后转向由 nNextIdx 指向的下一行，直到 nNextIdx 为 -1 为止。在当前函数的栈回退工作结束后，异常处理器可沿当前函数栈框架内 piPrev 的值回溯到异常处理链中的上一节点重复上述操作，直到所有回退工作完成为止。&lt;/p&gt;

&lt;p&gt;值得一提的是，nStep 的值完全在编译时决定，运行时仅需执行若干次简单的整形立即数赋值（通常是直接赋值给CPU里的某个寄存器）。此外，对于所有内部类型以及使用了默认构造、析构方法（并且它的所有成员和基类也使用了默认方法）的类型，其创建和销毁均不影响 nStep 的值。&lt;/p&gt;

&lt;p&gt;注意：如果在栈回退的过程中，由于析构函数的调用而再次引发了异常（异常中的异常），则被认为是一次异常处理机制的严重失败。此时进程将被强行禁止。为防止出现这种情况，应在所有可能抛出异常的析构函数中使用“std::uncaught_exception()”方法判断当前是否正在进行栈回退（即：存在一个未捕获或未完全处理完毕的异常）。如是，则应抑制异常的再次抛出。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;异常捕获机制&lt;/h1&gt;

&lt;p&gt;一个异常被抛出时，就会立即引发 C++ 的异常捕获机制：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/inside_exception_exceptioncatch.png&quot; alt=&quot;图4C++异常捕获机制&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上一小节中，我们已经看到了 nStep 变量在跟踪对象构造、析构方面的作用。实际上 nStep 除了能够跟踪对象创建、销毁阶段以外，还能够标识当前执行点是否在 try 块中，以及（如果当前函数有多个 try 块的话）究竟在哪个 try 块中。这是通过在每一个 try 块的入口和出口各为 nStep 赋予一个唯一 ID 值，并确保 nStep 在对应 try 块内的变化恰在此范围之内来实现的。&lt;/p&gt;

&lt;p&gt;在具体实现异常捕获时，首先，C++ 异常处理器检查发生异常的位置是否在当前函数的某个 try 块之内。这项工作可以通过将当前函数的 nStep 值依次在 piHandler 指向 tblTryBlocks[] 表的条目中进行范围为 [nBeginStep, nEndStep) 的比对来完成。&lt;/p&gt;

&lt;p&gt;例如：若图4 中的 FuncB 在 nStep == 2 时发生了异常，则通过比对 FuncB 的 tblTryBlocks[] 表发现 2∈[1, 3)，故该异常发生在 FuncB 内的第一个 try 块中。&lt;/p&gt;

&lt;p&gt;其次，如果异常发生的位置在当前函数中的某个 try 块内，则尝试匹配该 tblTryBlocks[] 相应条目中的 tblCatchBlocks[] 表。tblCatchBlocks[] 表中记录了与指定 try 块配套出现的所有 catch 块相关信息，包括这个 catch 块所能捕获的异常类型及其起始地址等信息。&lt;/p&gt;

&lt;p&gt;若找到了一个匹配的 catch 块，则复制当前异常对象到此 catch 块，然后跳转到其入口地址执行块内代码。&lt;/p&gt;

&lt;p&gt;否则，则说明异常发生位置不在当前函数的 try 块内，或者这个 try 块中没有与当前异常相匹配的 catch 块，此时则沿着函数栈框架中 piPrev 所指地址（即：异常处理链中的上一个节点）逐级重复以上过程，直至找到一个匹配的 catch 块或到达异常处理链的首节点。对于后者，我们称为发生了未捕获的异常，对于 C++ 异常处理器而言，未捕获的异常是一个严重错误，将导致当前进程被强制结束。&lt;/p&gt;

&lt;p&gt;注意：虽然在图4示例中的 tblTryBlocks[] 只有一个条目，这个条目中的 tblCatchBlocks[] 也只有一行。但是在实际情况中，这两个表中都允许有多条记录。意即：一个函数中可以有多个 try 块，每个 try 块后均可跟随多个与之配套的 catch 块。&lt;/p&gt;

&lt;p&gt;注意：按照标准意义上的理解，异常时的栈回退是伴随着异常捕获过程沿着异常处理链逐层向上进行的。但是有些编译器是在先完成异常捕获后再一次性进行栈回退的。无论具体实现使用了哪种方式，除非正在开发一个内存严格受限的嵌入式应用，通常我们按照标准语意来理解都不会产生什么问题。&lt;/p&gt;

&lt;p&gt;备注：实际上 tblCatchBlocks 中还有一些较为关键但被故意省略的字段。比如指明该 catch 块异常对象复制方式（传值（拷贝构造）或传址（引用或指针））的字段，以及在何处存放被复制的异常对象（相对于入口地址的偏移位置）等信息。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;异常的抛出&lt;/h1&gt;

&lt;p&gt;接下来讨论整个 C++ 异常处理机制中的最后一个环节，异常的抛出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/inside_exception_exceptionthrow.png&quot; alt=&quot;图5C++异常抛出机制&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在编译一段 C++ 代码时，编译器会将所有 throw 语句替换为其 C++ 运行时库中的某一指定函数，这里我们叫它 __CxxRTThrowExp（与本文提到的所有其它数据结构和属性名一样，在实际应用中它可以是任意名称）。该函数接收一个编译器认可的内部结构（我们叫它 EXCEPTION 结构）。这个结构中包含了待抛出异常对象的起始地址、用于销毁它的析构函数，以及它的 type_info 信息。对于没有启用 RTTI 机制（编译器禁用了 RTTI 机制或没有在类层次结构中使用虚表）的异常类层次结构，可能还要包含其所有基类的 type_info 信息，以便与相应的 catch 块进行匹配。&lt;/p&gt;

&lt;p&gt;在图5中的深灰色框图内，我们使用 C++ 伪代码展示了函数 FuncA 中的 “throw myExp(1);” 语句将被编译器最终翻译成的样子。实际上在多数情况下，__CxxRTThrowExp 函数即我们前面曾多次提到的“异常处理器”，异常捕获和栈回退等各项重要工作都由它来完成。&lt;/p&gt;

&lt;p&gt;__CxxRTThrowExp 首先接收（并保存）EXCEPTION 对象；然后从 TLS：Current ExpHdl 处找到与当前函数对应的 piHandler、nStep 等异常处理相关数据；并按照前文所述的机制完成异常捕获和栈回退。由此完成了包括“抛出”-&amp;gt;“捕获”-&amp;gt;“回退”等步骤的整套异常处理机制。&lt;/p&gt;

&lt;h1 id=&quot;windows-&quot;&gt;Windows 中的结构化异常处理&lt;/h1&gt;

&lt;p&gt;Microsoft Windows 带有一种名为“结构化异常处理”的机制，非常著名的“内存访问违例”出错对话框就是该机制的一种体现。Windows 结构化异常处理与前文讨论的 C++ 异常处理机制有惊人的相似之处，同样使用类似的链式结构实现。对于 Windows 下的应用程序，只需使用 SetUnhandledExceptionFilter API 注册异常处理器；用 FS:[0] 替代前文所述的 TLS: Current ExpHdl 等很少的改动，即可将此两种错误处理机制合而为一。这样做的优势十分明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于可直接借助操作系统提供的机制，所以简化了 C++ 异常处理器的实现。&lt;/li&gt;
  &lt;li&gt;使“catch (…)” 块得以捕获操作系统产生的异常（如：“内存访问违例”等等）。&lt;/li&gt;
  &lt;li&gt;使操作系统的异常处理机制能够捕获所有 C++ 异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上，大多数 Windows 下的 C++ 编译器的异常机制均使用这种方式实现。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;异常处理机制的开销分析&lt;/h1&gt;

&lt;p&gt;至此，我们已完整地阐述了整套 C++ 异常处理机制的实现原理。我在本文的开头曾提到，作为一名 C++ 程序员，了解其某一特性的实现原理主要是为了避免错误地使用该特性。要达到这个目的，还要在了解实现原理的基础上进行一些额外的开销分析工作：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;特性&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;时间开销&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;空间开销&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;EHDL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无运行时开销&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每“C++函数”一个 EHDL 对象，其中的 tblTryBlocks[] 成员仅在函数中包含至少一个 try 块时使用。典型情况下小于 64 字节。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;C++栈框架&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;极高的 O(1) 效率，每次调用时进行3次额外的整形赋值和一次 TLS 访问。&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每 调用两个指针和一个整形开销。典型情况下小于 16 字节。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;step 跟踪&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;极高的 O(1) 效率每次进出 try 块或对象构造/析构一次整形立即数赋值。&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无（已记入 C++ 栈框架中的相应项目）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;异常的抛出、捕获和栈回退&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;异常的抛出是一次 O(1) 级操作。在单个函数中进行捕获和栈回退也均为 O(1) 操作。&lt;br /&gt;&lt;br /&gt; 但异常捕获的总体成本为 O(m)，其中 m 等于当前函数调用栈中，从抛出异常的位置到达匹配 catch 块之间所经过的函数调用中，包含 try 块（即：定义了有效 tblTryBlocks[]）的函数个数。&lt;br /&gt;&lt;br /&gt; 栈回退的总成本为 O(n)，其中 n 等于当前函数调用栈中，从抛出异常的位置到达匹配 catch 块之间所经过的函数调用数。&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在异常处理结束前，需保存异常对象及其析构函数指针和相应的 type_info 信息。&lt;br /&gt;&lt;br /&gt; 具体根据对象尺寸、编译器选项（是否开启 RTTI）及异常捕获器的参数传递方式（传值或传址）等因素有较大变化。典型情况下小于 256 字节。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看出，在没有抛出异常时，C++ 的异常处理机制是十分有效的。在有异常被抛出后，可能会依当前函数调用栈的情形进行若干次整形比较（try块表匹配）操作，但这通常不会超过几十次。对于大多数 15 年前的 CPU 来说，整形比较也只需 1 时钟周期，所以异常捕获的效率还是很高的。栈回退的效率则与 return 语句基本相当。&lt;/p&gt;

&lt;p&gt;考虑到即使是传统的函数调用、错误处理和逐级返回机制也不是没有代价的。这些开销在绝大多数情形下仍可以接受。空间开销方面，每“C++ 函数”一个 EHDL 结构体的引入在某些极端情形下会明显增加目标文件尺寸和内存开销。但是典型情况下，它们的影响并不大，但也没有小到可以完全忽略的程度。如果正在为一个资源严格受限的环境开发应用程序，你可能需要考虑关闭异常处理和 RTTI 机制以节约存储空间。&lt;/p&gt;

&lt;p&gt;以上讨论的是一种典型的异常机制的实现方式，各具体编译器厂商可能有自己的优化和改进方案，但总体的出入不会很大。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;小节&lt;/h1&gt;

&lt;p&gt;异常处理是 C++ 中十分有用的崭新特性之一。在绝大多数情况下，它们都有着优异的表现和令人满意的时空效率。异常处理本质上是另一种返回机制。但无论从软件工程、模块设计、编码习惯还是时空效率等角度来说，除了在有充分文档说明的前提下，偶尔可用来替代替代传统的 setjmp/longjmp 功能外，应保证只将其用于程序的错误处理机制中。&lt;/p&gt;

&lt;p&gt;此外，由于长跳转的使用既易于出错，又难于理解和维护。在编码过程中也应当尽量避免使用。关于异常的一般性使用说明，请参考：&lt;a href=&quot;http://baiy.cn/doc/cpp/index.htm#代码风格与版式_异常&quot;&gt;代码风格与版式：异常&lt;/a&gt;。&lt;/p&gt;

</description>
				
				<pubDate>Wed, 25 May 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/c/c++/2016/05/25/Inside_Exception/</link>
				<guid isPermaLink="true">http://foocoder.github.io/c/c++/2016/05/25/Inside_Exception/</guid>
			</item>
		
			<item>
				<title>RTTI、虚函数和虚基类的实现方式、开销分析及使用指导</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;Ps: 文章系转自&lt;a href=&quot;http://baiy.cn&quot;&gt; @白杨 &lt;/a&gt;先生的&lt;a href=&quot;http://baiy.cn//doc/cpp/index.htm&quot;&gt; C++编码规范与指导 &lt;/a&gt;中一文，&lt;a href=&quot;http://baiy.cn/doc/cpp/inside_rtti.htm&quot;&gt;原文链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;“在正确的场合使用恰当的特性” 对称职的C++程序员来说是一个基本标准。想要做到这点，首先要了解语言中每个特性的实现方式及其开销。本文主要讨论相对于传统 C 而言，对效率有影响的几个C++新特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译时开销&lt;/li&gt;
  &lt;li&gt;运行时开销&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相对于传统的 C 语言，C++ 引入的额外开销体现在以下两个方面：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;编译时开销&lt;/h2&gt;

&lt;p&gt;模板、类层次结构、强类型检查等新特性，以及大量使用了这些新特性的 STL 标准库都增加了编译器负担。但是应当看到，这些新机能在不降低，甚至（由于模板的内联能力）提升了程序执行效率的前提下，明显减轻了广大 C++ 程序员的工作量。&lt;/p&gt;

&lt;p&gt;用几秒钟的CPU时间换取几人日的辛勤劳动，附带节省了日后调试和维护代码的时间，这点开销当算超值。&lt;/p&gt;

&lt;p&gt;当然，在使用这些特性的时候，也有不少优化技巧。比如：编译一个 广泛依赖模板库的大型软件时，几条显式实例化指令就可能使编译速度提高几十倍；恰当地组合使用部分专门化和完全专门化，不但可以最优化程序的执行效率，还可以让同时使用多种不同参数实例化一套模板的程序体积显著减小……&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;运行时开销&lt;/h2&gt;

&lt;p&gt;运行时开销恐怕是程序员最关心的问题之一了。相对与传统C程序而言，C++中有可能引入额外运行时开销的新特性包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;虚基类&lt;/li&gt;
  &lt;li&gt;虚函数&lt;/li&gt;
  &lt;li&gt;RTTI（dynamic_cast和typeid）&lt;/li&gt;
  &lt;li&gt;异常&lt;/li&gt;
  &lt;li&gt;对象的构造和析构&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于其中第四点：异常，对于大多数现代编译器来说，在正常情况（未抛出异常）下，try块中的代码执行效率和普通代码一样高，而且由于不再需要使用传统上通过返回值或函数调用来判断错误的方式，代码的实际执行效率还可能进一步提高。抛出和捕捉异常的效率也只是在某些情况下才会稍低于函数正常返回的效率，何况对于一个编写良好的程序，抛出和捕捉异常的机会应该不多。关于异常使用的详细讨论，参见：C++编码规范正文中的相关部分和C++异常机制的实现方式和开销分析一节。&lt;/p&gt;

&lt;p&gt;而第五点，对象的构造和析构开销也不总是存在。对于不需要初始化/销毁的类型，并没有构造和析构的开销，相反对于那些需要初始化/销毁的类型来说，即使用传统的C方式实现，也至少需要与之相当的开销。这里要注意的一点是尽量不要让构造和析构函数过于臃肿，特别是在一个类层次结构中更要注意。时刻保持你的构造、析构函数中只有最必要的初始化和销毁操作，把那些并不是每个（子）对象都需要执行的操作留给其他方法和派生类去解决。&lt;/p&gt;

&lt;p&gt;其实对一个优秀的编译器而言，C++的各种特性本身就是使用C/汇编加以千锤百炼而最优化实现的。可以说，想用C甚至汇编比编译器更高效地实现某个C++特性几乎是不可能的。要是真能做到这一点的话，大侠就应该去写个编译器造福广大程序员才对～&lt;/p&gt;

&lt;p&gt;C++之所以 被广泛认为比C“低效”，其根本原因在于：由于程序员对某些特性的实现方式及其产生的开销不够了解，致使他们在错误的场合使用了错误的特性。而这些错误基本都集中在：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;把异常当作另一种流控机制，而不是仅将其用于错误处理中&lt;/li&gt;
  &lt;li&gt;一个类和/或其基类的构造、析构函数过于臃肿，包含了很多非初始化/销毁范畴的代码&lt;/li&gt;
  &lt;li&gt;滥用或不正确地使用RTTI、虚函数和虚基类机制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中前两点上文已经讲过，下面讨论第三点。&lt;/p&gt;

&lt;p&gt;为了说明RTTI、虚函数和虚基类的实现方式，这里首先给出一个经典的菱形继承实例，及其具体实现（为了便于理解，这里故意忽略了一些无关紧要的优化）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/inside_rtti.png&quot; alt=&quot;钻石型继承的典型内存布局&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中虚箭头代表偏移，实箭头代表指针&lt;/p&gt;

&lt;p&gt;由上图得到每种特性的运行时开销如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;特性&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;时间开销&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;空间开销&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RTTI&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;几次整形比较和一次取址操作（可能还会有1、2次整形加法）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每类型一个type_info对象（包括类型ID和类名称），典型情况下小于32字节&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;虚函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一次整形加法和一次指针间接引用&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每类型一个虚表，典型情况下小于128字节 &lt;br /&gt;&lt;br /&gt;每对象若干个（大部分情况下是一个）虚表指针，典型情况下小于8字节&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;虚基类&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;从虚继承的子类中访问虚基类的数据成员或其虚函数时，将增加两次指针间接引用和一次整形加法（部分情况下可以优化为一次指针间接引用）。&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每类型一个虚基类表，典型情况下小于32字节&lt;br /&gt; &lt;br /&gt;每对象若干虚基类表指针，典型情况下小于8字节&lt;br /&gt; &lt;br /&gt;在同时使用了虚函数的时候，虚基类表可以合并到虚表（virtual table）中，每对象的虚基类表指针（vbptr）也可以省略（只需vptr即可）。实际上，很多实现都是这么做的。 这样做的缺点是需要为一些中间类型（如：B1、B2 等）准备多个虚表。 &lt;br /&gt;&lt;br /&gt;如果指定类型在其类层次结构中只有一个虚基类（大部分使用了虚基类的情况下都是如此，如：上例中就只有 BB 一个虚基类），则可将 vbptr 直接替换为虚基类的偏移地址，这样做将可节省一次指针间接引用，从而提高效率。很多编译器都会自动开启这类优化措施。&lt;br /&gt; &lt;br /&gt;此外，由于在很多原本需要访问虚表内 offset 字段的场合中（例如：调用某些虚函数时），该值都是编译时已知的。此时只需一个整形立即数加法即可完成从基类对象到派生类 this 指针的转换。因此，在不怎么影响时间效率的前提下，可以仅保留一个 vbptr 指针（意即：上例中 B2 内的 vbptr 可以被省略）。这种优化方式常常与前文提到的，在单虚基类的场合中将 vbptr 直接替换为虚基类偏址的做法一同使用，以期在时间效率和空间效率间取得较好的平衡，例如：VC 就经常使用这样的优化方式。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;其中“每类型”或“每对象”是指用到该特性的类型/对象。对于未用到这些功能的类型及其对象，则不会增加上述开销&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，关于老天“饿时掉馅饼、睡时掉老婆”等美好传说纯属谣言。但凡人工制品必不完美，总有设计上的取舍，有其适应的场合也有其不适用的地方。&lt;/p&gt;

&lt;p&gt;C++中的每个特性，都是从程序员平时的生产生活中逐渐精化而来的。在不正确的场合使用它们必然会引起逻辑、行为和性能上的问题。对于上述特性，应该只在必要、合理的前提下才使用。&lt;/p&gt;

&lt;p&gt;“dynamic_cast” 用于在类层次结构中漫游，对指针或引用进行自由的向上、向下或交叉强制。”typeid” 则用于获取一个对象或引用的确切类型，与 “dynamic_cast” 不同，将 “typeid” 作用于指针通常是一个错误，要得到一个指针指向之对象的type_info，应当先将其解引用（例如：”typeid(*p);”）。&lt;/p&gt;

&lt;p&gt;一般地讲，能用虚函数解决的问题就不要用 “dynamic_cast”，能够用 “dynamic_cast” 解决的就不要用 “typeid”。比如：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//反面教材
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CShape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CCircle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CTriangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CSqucre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;以上代码用 “dynamic_cast” 写会稍好一点，当然最好的方式还是在CShape里定义名为 “rotate” 的虚函数。&lt;/p&gt;

&lt;p&gt;虚函数是C++众多运行时多态特性中开销最小，也最常用的机制。虚函数的好处和作用这里不再多说，应当注意在对性能有苛刻要求的场合，或者需要频繁调用，对性能影响较大的地方（比如每秒钟要调用成千上万次，而自身内容又很简单的事件处理函数）要慎用虚函数。&lt;/p&gt;

&lt;p&gt;需要特别说明的一点是：虚函数的调用开销与通过函数指针的间接函数调用（例如：经典C程序中常见的，通过指向结构中的一个函数指针成员调用；以及调用DLL/SO中的函数等常见情况）是相当的。比起函数调用本身的开销（保存现场-&amp;gt;传递参数-&amp;gt;传递返回值-&amp;gt;恢复现场）来说，一次指针间接引用是微不足道的。这就使得在绝大部分可以使用函数的场合中都能够负担得起虚方法的些微额外开销。&lt;/p&gt;

&lt;p&gt;作为一种支持多继承的面向对象语言，虚基类有时是保证类层次结构正确一致的一种必不可少的手段。但在需要频繁使用基类提供的服务，又对性能要求较高的场合，应该尽量避免使用它。在基类中没有数据成员的场合，也可以解除使用虚基类。例如，在上图中，如果类 “BB” 中不存在数据成员，那么 “BB” 就可以作为一个普通基类分别被 “B1” 和 “B2” 继承。这样的优化在达到相同效果的前提下，解除了虚基类引起的开销。不过这种优化也会带来一些问题：从 “DD” 向上强制到 “BB” 时会引起歧义，破坏了类层次结构的逻辑关系。&lt;/p&gt;

&lt;p&gt;上述特性的空间开销一般都是可以接受的，当然也存在一些特例，比如：在存储布局需要和传统C结构兼容的场合、在考虑对齐的场合、在需要为一个本来尺寸很小的类同时实例化许多对象的场合等等。&lt;/p&gt;
</description>
				
				<pubDate>Tue, 24 May 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/c/c++/2016/05/24/RTTI%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%BC%80%E9%94%80%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%9F%A5%E9%81%93/</link>
				<guid isPermaLink="true">http://foocoder.github.io/c/c++/2016/05/24/RTTI%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%BC%80%E9%94%80%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%9F%A5%E9%81%93/</guid>
			</item>
		
			<item>
				<title>Linux IO模式及select、poll、epoll详解</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;blockquote&gt;
  &lt;p&gt;本文系转自@人云思云 于 segmentfault 的一篇博文，&lt;a href=&quot;https://segmentfault.com/a/1190000003063859&quot;&gt;原作链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文讨论的背景是Linux环境下的network IO。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;一 概念说明&lt;/h1&gt;

&lt;p&gt;在进行解释之前，首先要说明几个概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户空间和内核空间&lt;/li&gt;
  &lt;li&gt;进程切换&lt;/li&gt;
  &lt;li&gt;进程的阻塞&lt;/li&gt;
  &lt;li&gt;文件描述符&lt;/li&gt;
  &lt;li&gt;缓存 I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用户空间与内核空间&lt;/h2&gt;

&lt;p&gt;现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;进程切换&lt;/h2&gt;

&lt;p&gt;为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。&lt;/p&gt;

&lt;p&gt;从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;保存处理机上下文，包括程序计数器和其他寄存器。&lt;/li&gt;
  &lt;li&gt;更新PCB信息。&lt;/li&gt;
  &lt;li&gt;把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。&lt;/li&gt;
  &lt;li&gt;选择另一个进程执行，并更新其PCB。&lt;/li&gt;
  &lt;li&gt;更新内存管理的数据结构。&lt;/li&gt;
  &lt;li&gt;恢复处理机上下文。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：总而言之就是很耗资源，具体的可以参考这篇文章：&lt;a href=&quot;http://guojing.me/linux-kernel-architecture/posts/process-switch/&quot;&gt;进程切换&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;进程的阻塞&lt;/h2&gt;

&lt;p&gt;正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。&lt;/p&gt;

&lt;p&gt;可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。&lt;code class=&quot;highlighter-rouge&quot;&gt;当进程进入阻塞状态，是不占用CPU资源的&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;fd&quot;&gt;文件描述符fd&lt;/h2&gt;

&lt;p&gt;文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。&lt;/p&gt;

&lt;p&gt;文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。&lt;/p&gt;

&lt;h2 id=&quot;io&quot;&gt;缓存 I/O&lt;/h2&gt;
&lt;p&gt;缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存 I/O 的缺点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。&lt;/p&gt;

&lt;h1 id=&quot;io-1&quot;&gt;二 IO模式&lt;/h1&gt;

&lt;p&gt;刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;等待数据准备 (Waiting for the data to be ready)&lt;/li&gt;
  &lt;li&gt;将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;阻塞 I/O（blocking IO）&lt;/li&gt;
  &lt;li&gt;非阻塞 I/O（nonblocking IO）&lt;/li&gt;
  &lt;li&gt;I/O 多路复用（ IO multiplexing）&lt;/li&gt;
  &lt;li&gt;信号驱动 I/O（ signal driven IO）&lt;/li&gt;
  &lt;li&gt;异步 I/O（asynchronous IO）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。&lt;/p&gt;

&lt;h2 id=&quot;ioblocking-io&quot;&gt;阻塞 I/O（blocking IO）&lt;/h2&gt;

&lt;p&gt;在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/NonblockingIO.png&quot; alt=&quot;Blocking I/O Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以，blocking IO的特点就是在IO执行的两个阶段都被block了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;iononblocking-io&quot;&gt;非阻塞 I/O（nonblocking IO）&lt;/h2&gt;
&lt;p&gt;linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/BlockingIO.png&quot; alt=&quot;Nonblocking I/O Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;io--io-multiplexing&quot;&gt;I/O 多路复用（ IO multiplexing）&lt;/h2&gt;
&lt;p&gt;IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/IOMultiplexing.png&quot; alt=&quot;I/O multiplexing Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;当用户进程调用了select，那么整个进程会被block&lt;/code&gt;，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。&lt;/p&gt;

&lt;p&gt;所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）&lt;/p&gt;

&lt;p&gt;在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。&lt;/p&gt;

&lt;h2 id=&quot;ioasynchronous-io&quot;&gt;异步 I/O（asynchronous IO）&lt;/h2&gt;
&lt;p&gt;Linux下的asynchronous IO其实用得很少。先看一下它的流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/AsynchronousIO.png&quot; alt=&quot;Asynchronous I/O Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;blocking和non-blocking的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;synchronous IO和asynchronous IO的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;&lt;/li&gt;
  &lt;li&gt;An asynchronous I/O operation does not cause the requesting process to be blocked;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。&lt;/p&gt;

&lt;p&gt;有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。&lt;/p&gt;

&lt;p&gt;而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;各个IO Model的比较如图所示&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/CompareIO.png&quot; alt=&quot;Comparison of the five I/O models&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。&lt;/p&gt;

&lt;h1 id=&quot;io-selectpollepoll&quot;&gt;三 I/O 多路复用之select、poll、epoll详解&lt;/h1&gt;

&lt;p&gt;select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）&lt;/p&gt;

&lt;h2 id=&quot;select&quot;&gt;select&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writefds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exceptfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。&lt;/p&gt;

&lt;p&gt;select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。&lt;/p&gt;

&lt;h2 id=&quot;poll&quot;&gt;poll&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pollfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pollfd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* file descriptor */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* requested events to watch */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;revents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* returned events witnessed */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从上面看，select和poll都需要在返回后，&lt;code class=&quot;highlighter-rouge&quot;&gt;通过遍历文件描述符来获取已经就绪的socket&lt;/code&gt;。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;epoll&quot;&gt;epoll&lt;/h2&gt;

&lt;p&gt;epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。&lt;/p&gt;

&lt;h3 id=&quot;epoll-1&quot;&gt;一 epoll操作过程&lt;/h3&gt;

&lt;p&gt;epoll操作过程需要三个接口，分别如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;int-epollcreateint-size&quot;&gt;1.int epoll_create(int size);&lt;/h4&gt;
&lt;p&gt;创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。&lt;/p&gt;

&lt;p&gt;当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。&lt;/p&gt;

&lt;h4 id=&quot;int-epollctlint-epfd-int-op-int-fd-struct-epollevent-event&quot;&gt;2.int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；&lt;/h4&gt;
&lt;p&gt;函数是对指定描述符fd执行op操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;epfd：是epoll_create()的返回值。&lt;/li&gt;
  &lt;li&gt;op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。&lt;/li&gt;
  &lt;li&gt;fd：是需要监听的fd（文件描述符）&lt;/li&gt;
  &lt;li&gt;epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* Epoll events */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;epoll_data_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* User data variable */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//events可以是以下几个宏的集合：
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;：表示对应的文件描述符可以读（包括对端&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCKET&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;正常关闭）；&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EPOLLOUT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：表示对应的文件描述符可以写；&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EPOLLPRI&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EPOLLERR&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：表示对应的文件描述符发生错误；&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EPOLLHUP&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：表示对应的文件描述符被挂断；&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EPOLLET&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;将&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLL&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;设为边缘触发&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Edge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Triggered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;模式，这是相对于水平触发&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Level&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Triggered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;来说的。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EPOLLONESHOT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的话，需要再次把这个&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;加入到&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLL&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;队列里&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;int-epollwaitint-epfd-struct-epollevent--events-int-maxevents-int-timeout&quot;&gt;3.int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);&lt;/h4&gt;
&lt;p&gt;等待epfd上的io事件，最多返回maxevents个事件。
参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;二 工作模式&lt;/h3&gt;
&lt;p&gt;　epoll对文件描述符的操作有两种模式：&lt;strong&gt;LT（level trigger）&lt;/strong&gt;和&lt;strong&gt;ET（edge trigger）&lt;/strong&gt;。LT模式是默认模式，LT模式与ET模式的区别如下：&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;LT模式&lt;/strong&gt;：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，&lt;code class=&quot;highlighter-rouge&quot;&gt;应用程序可以不立即处理该事件&lt;/code&gt;。下次调用epoll_wait时，会再次响应应用程序并通知此事件。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;ET模式&lt;/strong&gt;：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，&lt;code class=&quot;highlighter-rouge&quot;&gt;应用程序必须立即处理该事件&lt;/code&gt;。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。&lt;/p&gt;

&lt;h4 id=&quot;lt&quot;&gt;1.LT模式&lt;/h4&gt;

&lt;p&gt;LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。&lt;/p&gt;

&lt;h4 id=&quot;et&quot;&gt;2.ET模式&lt;/h4&gt;

&lt;p&gt;ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)&lt;/p&gt;

&lt;p&gt;ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;3.总结&lt;/h4&gt;

&lt;p&gt;假如有这样一个例子：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符&lt;/li&gt;
  &lt;li&gt;这个时候从管道的另一端被写入了2KB的数据&lt;/li&gt;
  &lt;li&gt;调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作&lt;/li&gt;
  &lt;li&gt;然后我们读取了1KB的数据&lt;/li&gt;
  &lt;li&gt;调用epoll_wait(2)……&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;LT模式：
如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。&lt;/p&gt;

&lt;p&gt;ET模式：
如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。&lt;/p&gt;

&lt;p&gt;当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，
读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;buflen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activeevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buflen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 在这里就当作是该次事件已处理处.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAGAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buflen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;// 这里表示对端的socket已正常关闭.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buflen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 需要再次读取
&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux 中的EAGAIN含义&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。&lt;/p&gt;

&lt;p&gt;例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。
又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;三 代码演示&lt;/h3&gt;
&lt;p&gt;下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define IPADDRESS   &quot;127.0.0.1&quot;
#define PORT        8787
#define MAXSIZE     1024
#define LISTENQ     5
#define FDSIZE      1000
#define EPOLLEVENTS 100
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;listenfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket_bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPADDRESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLEVENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//创建一个描述符
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FDSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//添加监听描述符事件
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listenfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//循环等待
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//该函数返回已经准备好的描述符事件数目
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLEVENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//处理接收到的连接
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;handle_events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listenfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//事件处理函数
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listenfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。
&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//根据描述符的类型和事件类型进行处理
&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listenfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;handle_accpet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listenfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;do_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EPOLLOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;do_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//添加事件
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLL_CTL_ADD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//处理接收到的连接
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_accpet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listenfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clifd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     
     &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr_in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cliaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     
     &lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;cliaddrlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     
     &lt;span class=&quot;n&quot;&gt;clifd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listenfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cliaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cliaddrlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clifd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;         
     &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;accpet error:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;         
         &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;accept a new client: %s:%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inet_ntoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cliaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sin_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cliaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sin_port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                       &lt;span class=&quot;c1&quot;&gt;//添加一个客户描述符和事件         
&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;add_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clifd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//读处理
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;         
        &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;read error:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;         
        &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//记住close fd        
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;delete_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//删除监听 
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;         
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;client close.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//记住close fd       
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;delete_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//删除监听 
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;     
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;         
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;read message is : %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        
        &lt;span class=&quot;c1&quot;&gt;//修改描述符对应的事件，由读改为写         
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;modify_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//写处理
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;     
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     
    &lt;span class=&quot;n&quot;&gt;nwrite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;     
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nwrite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;         
        &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;write error:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        
        &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//记住close fd       
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;delete_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//删除监听    
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;modify_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLLIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//删除事件
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delete_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLL_CTL_DEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//修改事件
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modify_event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;     
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOLL_CTL_MOD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;注：另外一端我就省了&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;epoll-2&quot;&gt;四 epoll总结&lt;/h3&gt;

&lt;p&gt;在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而&lt;strong&gt;epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。&lt;/strong&gt;
(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;epoll的优点主要是一下几个方面：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
				
				<pubDate>Sat, 07 May 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/linux/2016/05/07/Linux-IO%E6%A8%A1%E5%BC%8F%E5%8F%8Aselect-poll-epoll%E8%AF%A6%E8%A7%A3/</link>
				<guid isPermaLink="true">http://foocoder.github.io/linux/2016/05/07/Linux-IO%E6%A8%A1%E5%BC%8F%E5%8F%8Aselect-poll-epoll%E8%AF%A6%E8%A7%A3/</guid>
			</item>
		
			<item>
				<title>Const 限定符</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;作为&lt;/p&gt;
</description>
				
				<pubDate>Sun, 03 Apr 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/c/c++/2016/04/03/Const%E9%99%90%E5%AE%9A%E7%AC%A6/</link>
				<guid isPermaLink="true">http://foocoder.github.io/c/c++/2016/04/03/Const%E9%99%90%E5%AE%9A%E7%AC%A6/</guid>
			</item>
		
			<item>
				<title>一道简单的题目引发的思考</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;本文来自于@吴秦(Tyler)的个人博客，详细的记录了博主一次发现问题，解决问题，发散问题的过程。本人很佩服博主的这种求本溯源的精神。转载过来留个念。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原文地址：&lt;a href=&quot;http://www.cnblogs.com/skynet/archive/2010/07/11/1775084.html&quot;&gt;一道简单的题目引发的思考&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;引言&lt;/h2&gt;

&lt;p&gt;昨晚一时兴起，我脑子就问自己下面的代码会输出什么，也不知道我脑子为什么有这个代码模型，只是模糊的有些印象：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;i = %d, j = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;您会怎样考虑这个问题呢？您不运行这个程序能准确地说出答案吗？我猜想肯定有大部分人不能肯定且准确地说出答案！如果您不能，这篇文章就是为你准备的，保证您看完之后豁然开朗！请细看下文，outline如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.诸君的回答
    &lt;ul&gt;
      &lt;li&gt;1.1 A君的回答&lt;/li&gt;
      &lt;li&gt;1.2 B君的回答&lt;/li&gt;
      &lt;li&gt;1.3 C君的回答&lt;/li&gt;
      &lt;li&gt;1.4 D君的回答&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2.编译器的输出
    &lt;ul&gt;
      &lt;li&gt;2.1 Visual Studio的输出&lt;/li&gt;
      &lt;li&gt;2.2 GCC的输出&lt;/li&gt;
      &lt;li&gt;2.3 Visual C++ 2010的输出&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3.分析
    &lt;ul&gt;
      &lt;li&gt;3.1 gcc编译器上的分析&lt;/li&gt;
      &lt;li&gt;3.2 分析gcc编译之后的汇编代码&lt;/li&gt;
      &lt;li&gt;3.3 vs编译器上的分析&lt;/li&gt;
      &lt;li&gt;3.4 分析VS编译之后的汇编代码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4.扩散思维
    &lt;ul&gt;
      &lt;li&gt;4.1 思维放射&lt;/li&gt;
      &lt;li&gt;4.2 VS的输出&lt;/li&gt;
      &lt;li&gt;4.3 GCC的输出&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5.感慨&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1.诸君的回答&lt;/h2&gt;

&lt;p&gt;我那这道题目问了几个人，他们的答案不尽相同。&lt;/p&gt;

&lt;h3 id=&quot;a&quot;&gt;1.1 A君的回答&lt;/h3&gt;

&lt;p&gt;因为i = 3，故依次i++=4，i++=5，++i=6，i最后输出为i = 6；但是由于前面两个++是后置++，最后一个++是前置++，故j = 3+4+6 = 13。&lt;/p&gt;

&lt;h3 id=&quot;b&quot;&gt;1.2 B君的回答&lt;/h3&gt;

&lt;p&gt;因为i = 3，故第一个i++后为4，第二个i++后为5，接着做i+i操作 = 5+5=10，最后与(++i)相加 = 10+6=16。&lt;/p&gt;

&lt;h3 id=&quot;c&quot;&gt;1.3 C君的回答&lt;/h3&gt;

&lt;p&gt;因为i = 3，故依次i++=4，i++=5，++i=6，i最后输出为i = 6；但是第一i、第二个i的++是后置++，先进行i+i操作，然后进行两次i++后置操作，故等价于(i)+(i) = 3+3=6，i++，i++，最后与++i=6相加等于12。&lt;/p&gt;

&lt;h3 id=&quot;d&quot;&gt;1.4 D君的回答&lt;/h3&gt;

&lt;p&gt;因为i = 3，故依次i++=4，i++=5，++i=6，i最后输出为i = 6；但是前面两个++都是后置++，故先做i+i+(++i)操作，然后才在i++,i++操作，第三个++是前置++，故等价于 i+i+(++i)=3+3+4=10，i++，i++。&lt;/p&gt;

&lt;p&gt;到底哪个人说得对呢？&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2.编译器的输出&lt;/h2&gt;

&lt;p&gt;首先让我们先来看看编译器会输出什么?&lt;/p&gt;

&lt;h3 id=&quot;visual-studio&quot;&gt;2.1 Visual Studio的输出&lt;/h3&gt;

&lt;p&gt;运行环境：Win7+VS2005 or VS2010，输出如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/160309_0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;gcc&quot;&gt;2.2 GCC的输出&lt;/h3&gt;

&lt;p&gt;运行环境：Ubuntu 10.04+gcc (Ubuntu 4.4.3-4ubuntu5) 4.4.3，运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/160309_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;visual-c&quot;&gt;2.3 Visual C++的输出&lt;/h3&gt;

&lt;p&gt;运行环境：Win7+VC2010，输出和VS一样，及i = 6 &amp;amp; j = 12&lt;/p&gt;

&lt;p&gt;看到这里你肯定想问why? why?? why???&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;3.分析&lt;/h2&gt;

&lt;p&gt;重编译器的输出结果来看貌似C君、D君的分析都是对的，这种差异跟编译器有直接的关系，因为对于这个表达式怎么编译还没有形成标准，编译器的结合方向不同，答案因此会有所不同。而且当然还包括运算符的优先级等。其实顶多算C君答对了一部分，其他几个人的回答都是错的，详情见下面的分析。&lt;/p&gt;

&lt;h3 id=&quot;gcc-1&quot;&gt;3.1 gcc编译器上的分析&lt;/h3&gt;

&lt;p&gt;(i++)+(i++)+(++i) &amp;lt;=&amp;gt; i+i+(++i); i++; i++;即如果表达式中含有i++，一律替换成i，然后在表达式之后进行i++操作。&lt;/p&gt;

&lt;p&gt;这样的话上面的代码就可以很好的理解了，即3+3+4=10。&lt;/p&gt;

&lt;h3 id=&quot;gcc-2&quot;&gt;3.2 分析gcc编译之后的汇编代码&lt;/h3&gt;

&lt;p&gt;可以对gcc编译之后的执行文件进行反编译分析验证正确性。在Linux下面可以用objdump –d xxx(执行文件)命令反汇编执行文件。反编译之后可以看到如下图所示的代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/160309_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明：Linux下采用的是AT＆T的汇编语法格式，Windows下面采用的是Intel汇编语法格式。二者的主要区别在于：&lt;/p&gt;

  &lt;p&gt;指令操作数的赋值方向是不同的&lt;br /&gt;
  Intel：第一个是目的操作数，第二个是源操作数 &lt;br /&gt;
  AT＆T：第一个是源操作数，第二个是目的操作数&lt;/p&gt;

  &lt;p&gt;指令前缀 &lt;br /&gt;
  AT＆T：寄存器前边要加上％，立即数前要加上$ &lt;br /&gt;
  Intel：没有这方面的要求&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;内存单元操作数 &lt;br /&gt;
  Intel：基地址使用［］ &lt;br /&gt;
  AT&amp;amp;T：  基地址使用（） &lt;br /&gt;
 比如：&lt;br /&gt;
       intel中  mov  ax,[bx] &lt;br /&gt;
       AT&amp;amp;T中 movl (%eax),%ebx&lt;/p&gt;

  &lt;p&gt;操作码的后缀 &lt;br /&gt;
    AT&amp;amp;T中操作码后面有一个后缀字母:“l” 32位,“w” 16位,“b” 8位 &lt;br /&gt;
    Intel却使用了在操作数前面加dword ptr, word ptr, byte ptr的格式&lt;br /&gt; 
  例如:&lt;br /&gt;
mov al,bl (Intel) &lt;br /&gt;
movb %bl %al (AT&amp;amp;T) &lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;AT＆T中跳转指令标号后的后缀 表示跳转方向，“f”表示向前，“b”表示向后&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面我们重点分析红框中的代码：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;movl  $0x3 ,0x1c(%esp) ;将3赋给i，即i=3 
mov   0x1c(%esp) ,%eax ;将esp中的i放到eax中 
add   %eax ,%eax       ;进行i+i操作，即3+3 
addl  $0x1 ,0x1c(%esp) ;对i进行加1操作，即表达式中的(++i) 
add   0x1c(%esp),%eax  ;将eax中i+i的结果6，加上++i之后的i，即6+4=10 
addl  $0x1 ,0x1c(%esp) ;对i进行加1操作，即表达式中的(i++) 
addl  $0x1 ,0x1c(%esp) ;对i进行加1操作，即表达式中的(i++)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;至此关键代码已经分析完成，由此可见我们之前对gcc编译器上的分析是正确的。&lt;/p&gt;

&lt;h3 id=&quot;vs&quot;&gt;3.3 vs编译器上的分析&lt;/h3&gt;

&lt;p&gt;(i++)+(i++)+(++i) &amp;lt;=&amp;gt;(++i)+i+i; i++; i++;即如果表达式中含有前置++i，首先执行++i操作；表达式中的i++，一律换成i，然后执行加法操作；最后在进行i++操作。&lt;/p&gt;

&lt;p&gt;这样的话上面的代码就可以很好的理解而来，即首先执行++i，i变为4了；然后进行i+i+i=4+4+4；i++，i++。&lt;/p&gt;

&lt;p&gt;其实对于VS/VC2010编译器中的可以总结为：当用于四则运算时，前置++/–的运算优先级最高，后置++/–的运算优先级最小，其它的居中。（跟你书上看到是不是不同！）&lt;/p&gt;

&lt;h3 id=&quot;vs-1&quot;&gt;3.4 分析VS编译之后的汇编代码&lt;/h3&gt;

&lt;p&gt;用W32Dasm反汇编vs编译生成的exe文件，追踪代码。我们可以看到如下图所示的代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/160309_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面重点分析一下框中代码：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;mov [ebp-08],3             ;将3赋给i，即i=3 
mov eax,dword ptr [ebp-08] ;将ebp中的i的值放到eax中，是&quot;累加器&quot;(accumulator), 它是很多加法乘法指令的缺省寄存器。dword ptr表示这是一个双字指针，即所要寻址的数据是一个双字（4字节） 
add eax,1                  ;对eax中的i进行加1操作 
mov dword ptr [ebp-08] ,eax;将eax中的i赋给ebp中i，即将i加1之后的值赋给i，也即达到i=i+1的效果 
mov ecx,dword ptr [ebp-08] ;将ebp中的i放到ecx中 
add ecx,dword ptr [ebp-08] ;将ebp中的值加上i，即4+4 
add ecx,dword ptr [ebp-08] ;将ebp中的值加上i，即4+4+4 
mov dword ptr [ebp-14],ecx ;将ecx中的值赋给j 
mov edx,dword ptr [ebp-08] ;将i放到edx中 
add edx,1                  ;对edx中的i进行加1操作 
mov dword ptr [ebp-08] ,edx;将edx中的i赋给ebp中i，即将i加1之后的值赋给i，也即达到i=i+1的效果 
mov eax,dword ptr [ebp-08] ;将i放到eax中 
add eax,1                  ;对eax中的i进行加1操作 
mov dword ptr [ebp-08] ,eax;将eax中的i赋给ebp中i，即将i加1之后的值赋给i，也即达到i=i+1的效果&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;至此，上面表达式的关键运算部分已经分析完成。从这里可以知道，上面我们地VS编译器的分析是正确的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;4.发散思维&lt;/h2&gt;

&lt;p&gt;可以说通过上面那么篇幅的介绍，我们对涉及前置++和后置++的加法运算表达式的计算过程有了一个清楚的认识，下面就我们发散一下我们的思维，释放我们的能量。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;4.1 思维放射&lt;/h3&gt;

&lt;p&gt;您看下面的代码会输出什么，现在知道了吧！&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt; 
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;i = 3&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;result1= (++i)+(++i) = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;n&quot;&gt;result2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;j = 3&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;result2= (j++)+(j++) = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;n&quot;&gt;result3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;k = 3&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;result3= (++k)+(++k)+(++k) = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;n&quot;&gt;result4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;l = 3&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;result4= (++l)+(++l)+(l++) = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;n&quot;&gt;result5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;m = 3&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;result5=(m++)+(m++)+(m++) = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;n&quot;&gt;result6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;n = 3&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;result6=(n++)+(++n)+(n++) = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;请不看结果先自己分析一下，然后和结果对比！&lt;/p&gt;

&lt;h3 id=&quot;vs-2&quot;&gt;4.2 VS的输出&lt;/h3&gt;

&lt;p&gt;运行环境：Win7+VS2005 or VS2010，输出如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/160309_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;gcc-3&quot;&gt;4.3 GCC的输出&lt;/h3&gt;

&lt;p&gt;运行环境：Ubuntu 10.04+gcc (Ubuntu 4.4.3-4ubuntu5) 4.4.3，运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/160309_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据前面我们挖掘到的规则，我们可以得到result3之外所有其它答案。最后，还有一点要说明的是：&lt;strong&gt;gcc中的加法运算表达死中，是按照从左到右按顺序，如果运算符两边有++i操作数，就先进行++i操作，然后进行加法运算；vs中的加法运算表达式中，则不一样，只要表达式中有++i操作数，就要先计算，最后才是进行加法运算。&lt;/strong&gt;这也是为什么result3不同的原因！加法运算可以扩展到减法、乘法、除法运算和前置–、后置–。但是如果是四则混合运算还要考虑加、减、乘、除的优先级问题。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;5.感慨&lt;/h2&gt;

&lt;p&gt;通过这么多分析，我们可以算得上是对涉及++、–的运算表达式计算过程有了透彻理解！
我在挖掘这个计算过程的路上，可是化了不少功夫也在刚开始分析汇编代码时遇到了一些困难，但这颗求知的心，推动着我坚持要去弄清楚它！
&lt;strong&gt;最后我想说：请不要写这种语句！理由很简单，它既不好理解又不好维护，最重要的是它的结果会因编译器的不同而不同。&lt;/strong&gt;&lt;/p&gt;

</description>
				
				<pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/c/c++/2016/03/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</link>
				<guid isPermaLink="true">http://foocoder.github.io/c/c++/2016/03/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</guid>
			</item>
		
			<item>
				<title>sizeof详解</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt; 操作符的作用是返回一个对象或类型名的长度， 返回类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;size_t&lt;/code&gt;，长度单位是字节。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;语法&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的语法主要有三种形式。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中表示了获取类型变量的内存长度或获取一个具体对象的长度。最常用的方式还是前两种，最后一种方式见的比较少。
需要注意的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;本质是一个操作符，所以会有&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof expr&lt;/code&gt;形式的语法，但该格式只针对于&lt;code class=&quot;highlighter-rouge&quot;&gt;expression&lt;/code&gt;，不能用于类型名。
&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.(成员访问符)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.*(成员指针访问运算符)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;::(域运算符)&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;?:(条件运算符)&lt;/code&gt;这5种运算符不能够被重载。
其中&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.*&lt;/code&gt;不能被重载是为了保证访问成员的功能不被改变，而&lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;则是其运算对象是类型而不是变量或一般表达式，不具备重载的特征。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用范围&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的计算一般发生在编译时，也就是说在程序编译的时候就可以计算出&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的大小。
所以可以将之看为常量表达式，如：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ok&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;不过C99标准规定了&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;也可以在运行时来计算，因此运行时的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的操作也是可以正常输出的&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//输入n=10;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;输出&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;不过据说VC6中该代码编译不通过，可能由于C99的标准没有实现的原因。
需要注意的一点是&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;对表达式，函数返回值等进行运算的时候这些表达式函数等等并不会被调用。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//i=0;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;不会调用&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;C99标准规定，函数、不能确定类型的表达式以及位域(bit-field)成员不能被计算&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的值：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//error
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//error
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//Ok, 4
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//error
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//error
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ok&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-2&quot;&gt;用法&lt;/h2&gt;

&lt;h3 id=&quot;sizeofchar--1&quot;&gt;1. sizeof(char) = 1&lt;/h3&gt;

&lt;p&gt;在《C++ Primer》中提到，对&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;类型或者值为&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;类型的表达式进行&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;操作保证得1。
这样从而&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;类型作为一个度量标准，不管编译器或者系统怎样，&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(char)&lt;/code&gt;始终为1。&lt;/p&gt;

&lt;h3 id=&quot;sizeof&quot;&gt;2. 对引用的sizeof等于存放该引用对象的内存大小&lt;/h3&gt;

&lt;p&gt;也就是说，如果A是对B的引用的话，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(A)&lt;/code&gt;将等译&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(B)&lt;/code&gt;。
但是说从内部实现的角度来看引用的话，引用应该跟指针类似，引用本身占用的空间大小应该是机器字长。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;但对引用的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;种种现象都显示出引用就是其本身的类型。诸如&lt;code class=&quot;highlighter-rouge&quot;&gt;typeid&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;等等。
这个引用跟指针的具体区别还需要继续研究。&lt;/p&gt;

&lt;h3 id=&quot;sizeofsizeof&quot;&gt;3. 对数组的sizeof等于对其元素的sizeof大小乘以数组的长度&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//10
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//6
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;需要注意的是&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的结果不是数组的长度，要想获得数组的长度可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;结果除以每个元素的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的大小。&lt;/p&gt;

&lt;h3 id=&quot;sizeof-1&quot;&gt;4. 对指针的sizeof等于存放该指针的内存大小&lt;/h3&gt;

&lt;p&gt;引用指针的区别，引用的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;给出的是指向的内存对象的大小，指针的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;给出的是指针的大小。
所以对于32bit系统而言，所有的指针的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;都是4，而对于64bit系统，则是8。&lt;/p&gt;

&lt;p&gt;如果想获得指针所指的对象的内存大小，则需要解引用。&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(*ptr)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里有一道经典的题，求i1,i2的值。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]){&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;可能大部分都会以为i1等于3。但实际上来看，这里的i1跟i2都是指针的长度。
函数在参数传递的时候，数组已经蜕变成了指针。
也就是说下面几种函数的声明是等价的&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;传递进去的参数都将是指针，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的长度也是指针的长度。&lt;/p&gt;

&lt;h3 id=&quot;strlen&quot;&gt;5. 与strlen的区别&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strlen(char*)&lt;/code&gt;是个求字符串实际长度的函数，返回字符串中不包括&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;的长度。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//10
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//5
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;\0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//10
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//0
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0123456789&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//10
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unkown&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;需要注意的是最后一个例子，如果字符的长度大于等于字符数组的大小时，导致判断str终止的&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;字符无法赋值进去，&lt;code class=&quot;highlighter-rouge&quot;&gt;c2&lt;/code&gt;的结尾是&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;strlen&lt;/code&gt;会一直向后检索到遇到&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;才停止，此时&lt;code class=&quot;highlighter-rouge&quot;&gt;strlen&lt;/code&gt;的值是不可靠的。&lt;/p&gt;

&lt;h3 id=&quot;struct&quot;&gt;6. Struct的内存对齐&lt;/h3&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;的内存大小就会涉及到内存对齐的问题了。&lt;/p&gt;

&lt;p&gt;举个简单的例子&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;乍一看我们会以为&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(S1) = sizeof(a)+sizeof(b)+sizeof(c)&lt;/code&gt;，应该等于1+8+4=13。
可实际上结果却是24。这正是内存对齐的影响。&lt;/p&gt;

&lt;p&gt;我们来看下内存对齐的几个规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;union&lt;/code&gt;的各个成员，第一个成员位于偏移量为0的位置，之后的每个数据成员的偏移量都必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;min(#pragma pack(n),sizeof(data))&lt;/code&gt;的整数倍。 (其中&lt;code class=&quot;highlighter-rouge&quot;&gt;#pragma pack(n)&lt;/code&gt;用来设置为n字节对齐,而&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(data)&lt;/code&gt;指该数据成员本身的长度)&lt;/li&gt;
  &lt;li&gt;在数据成员完成各自的对齐之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;union&lt;/code&gt;本身也需要进行对齐，对齐按照&lt;code class=&quot;highlighter-rouge&quot;&gt;min(#pragma pack(n), sizeof(maxdata))&lt;/code&gt;的整数倍对齐。(&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(maxdata)&lt;/code&gt;指的是数据成员中占内存最大成员的大小。)&lt;/li&gt;
  &lt;li&gt;如果数据成员里边有复杂数据类型，诸如&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;union&lt;/code&gt;或者数组之类的数据成员，这里&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(maxdata)&lt;/code&gt;会将复杂数据成员拆分成基本成员，长度还是按照基本数据成员的最长数据来算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再来看上边那个例子，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;char a&lt;/code&gt;的偏移量是0，&lt;code class=&quot;highlighter-rouge&quot;&gt;double b&lt;/code&gt;的偏移量应该是本身的整数倍，所以是8。最后&lt;code class=&quot;highlighter-rouge&quot;&gt;int c&lt;/code&gt;的偏移量是16，满足规则。但整个&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;的长度现在是16+4=20。
要满足&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;对齐后是最宽的数据的整数倍，所以要在&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;后边填充4个字节得到24。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;的某个成员相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;首地址的偏移量可以通过宏&lt;code class=&quot;highlighter-rouge&quot;&gt;offsetof()&lt;/code&gt;来获取。这个宏定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;stddef.h&lt;/code&gt;中，如下&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define offsetof(s,m) (size_t) &amp;amp; (((s * )0)-&amp;gt;m)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;bit-field&quot;&gt;位域(bit-field)上的内存对齐&lt;/h4&gt;

&lt;p&gt;虽然说对&lt;code class=&quot;highlighter-rouge&quot;&gt;bit-field&lt;/code&gt;的成员不能够进行&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;操作，但是我们仍然可以对&lt;code class=&quot;highlighter-rouge&quot;&gt;bit-field&lt;/code&gt;的整体来进行&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;的操作的。
&lt;code class=&quot;highlighter-rouge&quot;&gt;bit-field&lt;/code&gt;的数据成员也要满足&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;上的内存对齐规则。
不过特别的，&lt;code class=&quot;highlighter-rouge&quot;&gt;bit-field&lt;/code&gt;还有一套自己的内存对齐规则。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；&lt;/li&gt;
  &lt;li&gt;如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；&lt;/li&gt;
  &lt;li&gt;如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式；&lt;/li&gt;
  &lt;li&gt;如果位域字段之间穿插着非位域字段，则不进行压缩；&lt;/li&gt;
  &lt;li&gt;整个结构体的总大小为最宽基本类型成员大小的整数倍。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-3&quot;&gt;内存对齐的作用&lt;/h4&gt;

&lt;p&gt;关于内存对齐的作用，这篇&lt;a href=&quot;http://www.cppblog.com/snailcong/archive/2009/03/16/76705.html&quot;&gt;博客&lt;/a&gt;有着详细的说明。
然后本人就转了过来。&lt;/p&gt;

&lt;p&gt;内存对齐的主要作用是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。&lt;/li&gt;
  &lt;li&gt;性能原因：经过内存对齐后，CPU的内存访问速度大大提升。具体原因稍后解释。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/sizeof0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是普通程序员心目中的内存印象，由一个个的字节组成，而CPU并不是这么看待的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/sizeof1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为memory access granularity（粒度） 本人把它翻译为“内存读取粒度” 。&lt;/p&gt;

&lt;p&gt;假设CPU要读取一个int型4字节大小的数据到寄存器中，分两种情况讨论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据从0字节开始&lt;/li&gt;
  &lt;li&gt;数据从1字节开始&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再次假设内存读取粒度为4。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/sizeof2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当该数据是从0字节开始时，很CPU只需读取内存一次即可把这4字节的数据完全读取到寄存器中。&lt;/li&gt;
  &lt;li&gt;当该数据是从1字节开始时，问题变的有些复杂，此时该int型数据不是位于内存读取边界上，这就是一类内存未对齐的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/sizeof3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时CPU先访问一次内存，读取0—3字节的数据进寄存器，并再次读取4—5字节的数据进寄存器，接着把0字节和6，7，8字节的数据剔除，最后合并1，2，3，4字节的数据进寄存器。对一个内存未对齐的数据进行了这么多额外的操作，大大降低了CPU性能。&lt;/p&gt;

&lt;p&gt;这还属于乐观情况了，上文提到内存对齐的作用之一为平台的移植原因，因为以上操作只有有部分CPU肯干，其他一部分CPU遇到未对齐边界就直接罢工了。&lt;/p&gt;

&lt;h4 id=&quot;pragma-pack&quot;&gt;关于pragma pack()&lt;/h4&gt;

&lt;p&gt;系统的&lt;code class=&quot;highlighter-rouge&quot;&gt;#pragma pack(n)&lt;/code&gt;，用来设置对齐单位的最大长度。
因为对齐的几条规则取的基本长度要求是&lt;code class=&quot;highlighter-rouge&quot;&gt;#pragma pack()&lt;/code&gt;设置的和数据中最长的基本数据类型的长度取&lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;运算。也就是说如果&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;设置为4的话，最大的对齐单位都不会超过4的。&lt;/p&gt;

&lt;p&gt;例如&lt;code class=&quot;highlighter-rouge&quot;&gt;#pragma pack(1)&lt;/code&gt;就是将所有的对齐按照1的整数倍来对齐，实际上就是没有进行对齐，所有数据都压缩紧凑排列。&lt;/p&gt;

&lt;p&gt;另外该属性也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;__attribute__&lt;/code&gt;来设置的。如&lt;code class=&quot;highlighter-rouge&quot;&gt;__attribute__((packed))&lt;/code&gt;即设置为紧凑模式，不进行压缩。
或者&lt;code class=&quot;highlighter-rouge&quot;&gt;__attribut__((aligned(4)))&lt;/code&gt;来制定对齐的基本单位是几个字节。&lt;/p&gt;

&lt;h4 id=&quot;struct-0&quot;&gt;struct 里长度为0的数组&lt;/h4&gt;

&lt;p&gt;理论上说长度为0的数组在标准C和C++中是不被允许的，但在GNU中这种用法却是合法的，被网上称之为&lt;code class=&quot;highlighter-rouge&quot;&gt;柔性数组&lt;/code&gt;。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;可以看到柔性数组并不占用空间。
它的最典型的用法就是位于数组中的最后一项，如上面所示，这样做主要是为了方便内存缓冲区的管理。
如果你将上面的长度为的数组换为指针，那么在分配内存时，需采用两步：首先，需为结构体分配一块内存空间；其次再为结构体中的成员变量分配内存空间。
这样两次分配的内存是不连续的，需要分别对其进行管理。
当使用长度为的数组时，则是采用一次分配的原则，一次性将所需的内存全部分配给它。
相反，释放时也是一样的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考资料&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;《C++ Primer》&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://baike.baidu.com/item/sizeof&quot;&gt;百度百科&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.cppblog.com/snailcong/archive/2009/03/16/76705.html&quot;&gt;内存对齐的规则以及作用&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://my.oschina.net/u/176416/blog/33054?fromerr=b73dXTh5&quot;&gt;浅析长度为0的数组&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
				
				<pubDate>Sun, 06 Mar 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/c/c++/2016/03/06/details-about-sizeof/</link>
				<guid isPermaLink="true">http://foocoder.github.io/c/c++/2016/03/06/details-about-sizeof/</guid>
			</item>
		
			<item>
				<title>Stack vs Heap</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;关于操作系统的内存管理方面有很多文献，最主要的方面在于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;之间的区别与联系。
这里翻译一篇&lt;a href=&quot;http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html&quot;&gt;gribblelab.org&lt;/a&gt;的教程，对&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;于&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;有个初步的了解。&lt;/p&gt;

&lt;p&gt;简单的介绍下文章的结构&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#part1&quot;&gt;Stack vs Heap&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#part2&quot;&gt;The Stack&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#part3&quot;&gt;The Heap&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#part4&quot;&gt;Stack vs Heap Pros and Cons&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#part4_1&quot;&gt;Stack&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#part4_2&quot;&gt;Heap&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#part5&quot;&gt;Examples&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#part6&quot;&gt;When to use the Heap?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#part7&quot;&gt;Links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;span-idpart1stack-vs-heapspan&quot;&gt;&lt;span id=&quot;part1&quot;&gt;Stack vs Heap&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;一般来讲，&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;即为栈，&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;即为堆。
两者分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;内存管理过程中的两大不同类型的存储空间。&lt;/p&gt;

&lt;h2 id=&quot;span-idpart2the-stackspan&quot;&gt;&lt;span id=&quot;part2&quot;&gt;The Stack&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;什么是&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;？它是内存中用来存储程序执行过程中各个函数(也包括&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数)创建的临时变量的区域。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;字如其名，其本质的结构就是数据结构中的&lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;类型。
它是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;FILO&lt;/code&gt;(先入后出)类型的数据结构，这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;完全由CPU进行操作与维护。
每当一个函数声明一个新临时变量的时候，系统会将这个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;里边中去。
而一旦一个函数执行完毕退出的时候，所有的由该函数创建的临时变量会被&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;出来，也就是说该变量的生存周期已经到期被删除了。
而本来存放该变量的&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;区域就可以重新被&lt;code class=&quot;highlighter-rouge&quot;&gt;Push&lt;/code&gt;一个新的变量。&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;的最大的优势在于，&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;的内存的管理由CPU来进行操作，并不需要你来操心。
你可以不用手动的分配内存，释放内存，因为这些工作都已经被CPU做了。
而且CPU操作的方式会更加高效，从而使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;方式来读写变量的速度会很快的。&lt;/p&gt;

&lt;p&gt;要理解&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;最关键的一点是理解一旦一个函数退出，其所有的临时变量都会被从&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;Pop&lt;/code&gt;出来。
因此本质上&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;中的变量都是&lt;code class=&quot;highlighter-rouge&quot;&gt;Local&lt;/code&gt;的。
与之相对应的概念就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Variable scope&lt;/code&gt;，我们称之为变量的生命周期，或者说&lt;code class=&quot;highlighter-rouge&quot;&gt;local&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;的概念。
C程序中经常遇到的一个Bug就是尝试从一个函数的外边访问该函数内部的变量或者当该函数退出后访问其内部变量。&lt;/p&gt;

&lt;p&gt;另外一个需要注意的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;的总的存储空间是有限制的，如果超出该存储大小会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack Overflow&lt;/code&gt;的错误而导致Crash。&lt;/p&gt;

&lt;p&gt;总结起来如下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;里的存储的内容会随着函数&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;局部变量而增加缩小。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;中不需要我们来手动的管理内存，变量的分配与内存的释放都是系统进行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;有着大小的限制，具体大小跟操作系统有关。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack Variables&lt;/code&gt;只有当创建该变量的函数运行时才有效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;span-idpart3the-heapspan&quot;&gt;&lt;span id=&quot;part3&quot;&gt;The Heap&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;则是内存中可以由程序员来管理的变量存储区域。相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;而言，&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;有着更大的自由性。
要想分配内存空间，你可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;函数或者&lt;code class=&quot;highlighter-rouge&quot;&gt;calloc()&lt;/code&gt;函数来申请空闲空间。
而当我们使用完内存，也必须通过&lt;code class=&quot;highlighter-rouge&quot;&gt;free()&lt;/code&gt;函数来释放掉已经分配好的空间。
也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;要有与之相对的&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;来对应。
否则的话就会导致&lt;code class=&quot;highlighter-rouge&quot;&gt;Memory Leak&lt;/code&gt;的现象。
因为我们申请的空间没有被释放，所以这块空间会一直被占用而得不到重新利用。
我们通常利用&lt;code class=&quot;highlighter-rouge&quot;&gt;valgrind&lt;/code&gt;这个工具来检测程序有没有&lt;code class=&quot;highlighter-rouge&quot;&gt;memory leak&lt;/code&gt;的现象。&lt;/p&gt;

&lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;不同的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;的大小都没有限制。
但一般而言，&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;上变量的读取速度相对&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;是有点慢的。
因为从底层考虑，&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;需要利用指针来访问内存的数据，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;直接访问就可以了。
间接访问总会比直接访问多一些指令。&lt;/p&gt;

&lt;p&gt;另外一点与&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;不同的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;上的变量可以由任何函数访问到，也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;上的变量本质上全局的。
但前提是你得有指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;区域的地址。&lt;/p&gt;

&lt;h2 id=&quot;span-idpart4stack-vs-heap-pros-and-consspan&quot;&gt;&lt;span id=&quot;part4&quot;&gt;Stack vs Heap Pros and Cons&lt;/span&gt;&lt;/h2&gt;

&lt;h3 id=&quot;span-idpart41stackspan&quot;&gt;&lt;span id=&quot;part4_1&quot;&gt;Stack&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;快速访问&lt;/li&gt;
  &lt;li&gt;不需要显式回收变量，释放内存&lt;/li&gt;
  &lt;li&gt;内存空间可以由CPU来进行高效管理，不会出现碎片&lt;/li&gt;
  &lt;li&gt;只针对局部变量&lt;/li&gt;
  &lt;li&gt;大小有限制&lt;/li&gt;
  &lt;li&gt;变量空间的大小不能改变&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;span-idpart42heapspan&quot;&gt;&lt;span id=&quot;part4_2&quot;&gt;Heap&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;变量可以在全局访问到&lt;/li&gt;
  &lt;li&gt;对内存大小没有限制&lt;/li&gt;
  &lt;li&gt;相对较慢的访问速度&lt;/li&gt;
  &lt;li&gt;空间的利用率不能被保障，可能由于内存的不断分配释放导致空间不连续产生碎片&lt;/li&gt;
  &lt;li&gt;程序员需要手动管理内存(申请释放空间)&lt;/li&gt;
  &lt;li&gt;变量空间大小可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;realloc&lt;/code&gt;函数来重新分配大小&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;span-idpart5examplesspan&quot;&gt;&lt;span id=&quot;part5&quot;&gt;Examples&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;一个关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;的小例子。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;multiplyByTwo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twice&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12345.67&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;double your salary is %.3f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiplyByTwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;double your salary is 24691.340&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数里前三行分别定义了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;以及一个三元素的&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;数组。
这三个变量会在&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数中被&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;区间。
一旦&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数退出程序结束，这些变量便会被从&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;出来而删除。
同样的函数&lt;code class=&quot;highlighter-rouge&quot;&gt;multiplyByTwo&lt;/code&gt;，在被调用的时候两个&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;变量会被&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;中去。
而当函数执行完毕，这两个变量也从而被&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;出来删除了。&lt;/p&gt;

&lt;p&gt;另外有个特例就是&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;变量。&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;变量并不会被存放在&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;上，而是存放到内存区域的&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;bss&lt;/code&gt;区域。
因为静态变量并不随着其创建函数的退出而消亡，因此不能放置到&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;区域上。&lt;/p&gt;

&lt;p&gt;下面一个关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;的小例子。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;multiplyByTwo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twice&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;twice&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12345.67&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;myList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;myList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;myList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twiceSalary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiplyByTwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;double your salary is %.3f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;twiceSalary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;twiceSalary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;我们利用&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;来申请&lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;上的空闲空间然后用&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;来释放不需要的空间。&lt;/p&gt;

&lt;h2 id=&quot;span-idpart6when-to-use-the-heapspan&quot;&gt;&lt;span id=&quot;part6&quot;&gt;When to use the Heap&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;When should you use the heap, and when should you use the stack?
If you need to allocate a large block of memory (e.g. a large array, or a big struct), and you need to keep that variable around a long time (like a global), then you should allocate it on the heap.
If you are dealing with relatively small variables that only need to persist as long as the function using them is alive, then you should use the stack, it’s easier and faster.
If you need variables like arrays and structs that can change size dynamically (e.g. arrays that can grow or shrink as needed) then you will likely need to allocate them on the heap, and use dynamic memory allocation functions like malloc(), calloc(), realloc() and free() to manage that memory “by hand”.
We will talk about dynamically allocated data structures after we talk about pointers.&lt;/p&gt;

&lt;h2 id=&quot;span-idpart7linksspan&quot;&gt;&lt;span id=&quot;part7&quot;&gt;Links&lt;/span&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/&quot;&gt;The Stack and the Heap&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap&quot;&gt;What and Where are the stack and heap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
				
				<pubDate>Thu, 03 Mar 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/c/c++/2016/03/03/Stack-vs-Heap/</link>
				<guid isPermaLink="true">http://foocoder.github.io/c/c++/2016/03/03/Stack-vs-Heap/</guid>
			</item>
		
			<item>
				<title>进程与线程的一个简单解释</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;本文转载于阮一峰老师的博客，对进程与线程做了一个生动的解释，理解起来清晰易懂，Very Nice!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原文地址：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html&quot;&gt;进程与线程的一个简单解释&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。&lt;/p&gt;

&lt;p&gt;最近，我读到一篇&lt;a href=&quot;http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html&quot;&gt;材料&lt;/a&gt;，发现有一个很好的类比，可以把它们解释地清晰易懂。&lt;/p&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。&lt;/p&gt;

&lt;p&gt;2.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。&lt;/p&gt;

&lt;p&gt;3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。&lt;/p&gt;

&lt;p&gt;4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个车间里，可以有很多工人。他们协同完成一个任务。&lt;/p&gt;

&lt;p&gt;5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;线程就好比车间里的工人。一个进程可以包括多个线程。&lt;/p&gt;

&lt;p&gt;6.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。&lt;/p&gt;

&lt;p&gt;7.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。&lt;/p&gt;

&lt;p&gt;8.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。&lt;/p&gt;

&lt;p&gt;9.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。&lt;/p&gt;

&lt;p&gt;10.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。
不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。&lt;/p&gt;

&lt;p&gt;11.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/procAndThre11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;操作系统的设计，因此可以归结为三点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;以多进程形式，允许多个任务同时运行；&lt;/li&gt;
  &lt;li&gt;以多线程形式，允许单个任务分成不同的部分运行；&lt;/li&gt;
  &lt;li&gt;提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（完）&lt;/p&gt;

</description>
				
				<pubDate>Thu, 03 Mar 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/os/2016/03/03/Processes-and-Threads/</link>
				<guid isPermaLink="true">http://foocoder.github.io/os/2016/03/03/Processes-and-Threads/</guid>
			</item>
		
			<item>
				<title>获取一个十进制数的最高位</title>
				
					
						<dc:creator>{&quot;name&quot;=&gt;&quot;MetaCoder&quot;, &quot;email&quot;=&gt;&quot;slow295185031@gmail.com&quot;, &quot;info&quot;=&gt;nil}</dc:creator>
					
				
				
					<description>&lt;p&gt;整理来自于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stackoverflow&lt;/code&gt;的这里&lt;a href=&quot;http://stackoverflow.com/questions/701322/how-can-you-get-the-first-digit-in-an-int-c/701621#701621&quot;&gt;http://stackoverflow.com/questions/701322/how-can-you-get-the-first-digit-in-an-int-c/701621#701621&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;问题描述：在给定的一个十进制的整数，如何能够快速的求得其十进制的最高位数值是多少？&lt;/p&gt;

&lt;h2 id=&quot;method-1&quot;&gt;Method 1&lt;/h2&gt;

&lt;p&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;to_string&lt;/code&gt;函数，将整数强制转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;类型，然后取数组中第一个字符，再将之转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//Method 1
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;很简单的一种思路，想当然的想法，但其效率肯定会很差的。&lt;/p&gt;

&lt;h2 id=&quot;method-2&quot;&gt;Method 2&lt;/h2&gt;

&lt;p&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;math&lt;/code&gt;中库函数，直接用整数除以不大于该整数最大的10的整数幂值，来获取其商。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//Method 2
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_MathFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;数学思路，比如11/10商1， 321/100 商3，非常简单，也没什么可讲的。
不过需要注意一点是log函数的参数必须为正值，如果测试代码中包含0的话需要特别处理下。
处理后应该如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_MathFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;method-3&quot;&gt;Method 3&lt;/h2&gt;

&lt;p&gt;前两类方法都是利用外部函数调用，相较而言速度肯定会比较慢的。
这里有一种相对速度较快的，也是比较好想的方法。
通过整除10的方法来循环得到整数的各位以及最高位。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//Method 3
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_Looping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;时间复杂度跟整数的十进制最高位数成正比。&lt;/p&gt;

&lt;h2 id=&quot;method-4&quot;&gt;Method 4&lt;/h2&gt;

&lt;p&gt;条件判断法。&lt;/p&gt;

&lt;p&gt;因为我们知道一个整数在计算机的存储中范围是有限的。
那我们就分情况来讨论该整数最邻近的10的指数幂，然后利用整除方式得到最高位值。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Method 4
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_Conditional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;可以看到，代码是最长的一个，因为我们需要讨论从1到最大范围内的10的幂值，但相对其他方式来说速度也是很快的。&lt;/p&gt;

&lt;h2 id=&quot;method-5&quot;&gt;Method 5&lt;/h2&gt;

&lt;p&gt;最后这个方法堪称完美。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//Method 5
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_Unrolled_Optimized&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;巧妙的利用二分法将&lt;code class=&quot;highlighter-rouge&quot;&gt;Method 4&lt;/code&gt;中的条件进一步拆解。最高可以处理到(10^16 - 1)的数值。
比如说3872865， 首先经过第二个&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;剩下387，然后第三个&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;后得到38，最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;则出来最终结果3。
简洁凝练迅速，太完美了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;性能对比&lt;/h2&gt;

&lt;p&gt;通过测试代码，&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环从0到10^9次，间隔为5，统计所有数的最高位数的总和。
结果如下所示:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;999999996&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;48.2231&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_MathFunc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;999999996&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;32.8894&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_Looping&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;999999996&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;8.66428&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_Conditional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;999999996&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.68092&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fn_Get_First_By_Unrolled_Optimized&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;999999996&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.87899&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;还是方法5的速度最快。
而第一种方式跟第二种方式由于调用外部函数，很是耗时。&lt;/p&gt;

</description>
				
				<pubDate>Sat, 13 Feb 2016 00:00:00 +0000</pubDate>
				<link>http://foocoder.github.io/algorithm/2016/02/13/%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E6%9C%80%E9%AB%98%E4%BD%8D/</link>
				<guid isPermaLink="true">http://foocoder.github.io/algorithm/2016/02/13/%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E6%9C%80%E9%AB%98%E4%BD%8D/</guid>
			</item>
		
	</channel>
</rss>
